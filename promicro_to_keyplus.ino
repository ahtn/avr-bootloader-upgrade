// The ideas used in this code are based off bootjacker:
// http://oneweekwonder.blogspot.com.au/2014/07/bootjacker-amazing-avr-bootloader-hack.html

#include <stdint.h>
#include <stdbool.h>

#include <avr/io.h>
#include <avr/boot.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <util/atomic.h>
#include <util/delay.h>

#define kSpmCsr (_SFR_IO_ADDR(SPMCSR))
#define kSpmCsrMem (kSpmCsr+0x20)

#define IOAddrInsMask(aPort) (((aPort&0x30)<<5)|(aPort&7))

// We prefer to write our custom SPM instruction in the last page of the
// bootloader. If we can't write to that block (because the SPM instruction
// itself is inside it, then write to the first block).
#define IDEAL_BLOCK_ADDR (FLASHEND - SPM_PAGESIZE + 1)

#define kStsIns 0x9200
#define kStsRegMask 0x01f0
#define kOutSpmCsrIns (0xb800 + IOAddrInsMask(kSpmCsr))
#define kOutSpmCsrRegMask 0x01f0
#define kSpmIns 0x95e8

#define kFlashPageSize (1<<kFlashPageSizeBits)
#define kFlashPageSizeInWords (1<<(kFlashPageSizeBits-1))
#define kFlashSpmEnMask (1<<0)
#define kFlashSpmEraseMask (1<<1)
#define kFlashSpmWritePageMask (1<<2)
#define kFlashSpmBlbSetMask (1<<3)
#define kFlashSpmRwwsReMask (1<<4)
#define kFlashSpmRwwsBusyMask (1<<6)

#define kFlashSpmEn kFlashSpmEnMask
#define kFlashSpmErase (kFlashSpmEraseMask|kFlashSpmEnMask)
#define kFlashSpmWritePage (kFlashSpmWritePageMask|kFlashSpmEnMask)
#define kFlashSpmBlbSet (kFlashSpmBlbSetMask|kFlashSpmEnMask)
#define kFlashSpmRwws (kFlashSpmRwwsReMask|kFlashSpmEnMask)
#define kFlashSpmRwwsBusy (kFlashSpmRwwsBusyMask)

// Debug LEDs
#define LED0_DDR DDRB
#define LED0_PORT PORTB
#define LED0_BIT _BV(0)

#define LED1_DDR DDRD
#define LED1_PORT PORTD
#define LED1_BIT _BV(5)

#define LED0_SETUP (LED0_DDR |= LED0_BIT)
#define LED1_SETUP (LED1_DDR |= LED1_BIT)

#define LED0_ON (LED0_PORT &= ~LED0_BIT)
#define LED1_ON (LED1_PORT &= ~LED1_BIT)

#define LED0_OFF (LED0_PORT |= LED0_BIT)
#define LED1_OFF (LED1_PORT |= LED1_BIT)

#define LED0_TOGGLE (LED0_PORT ^= LED0_BIT)
#define LED1_TOGGLE (LED1_PORT ^= LED1_BIT)

// 4kb version used for replacing pro micro bootloader
const uint16_t bootloader_size = 4096;

const PROGMEM uint8_t bootloader_data[] = {
    0x11, 0x24, 0x1f, 0xbe, 0xcf, 0xef, 0xda, 0xe0, 0xde, 0xbf
    , 0xcd, 0xbf, 0x11, 0xe0, 0xa0, 0xe0, 0xb1, 0xe0, 0xe0, 0xe9
    , 0xf3, 0xe7, 0x02, 0xc0, 0x05, 0x90, 0x0d, 0x92, 0xa6, 0x35
    , 0xb1, 0x07, 0xd9, 0xf7, 0x0e, 0x94, 0x83, 0x39, 0x0c, 0x94
    , 0xc6, 0x39, 0xfc, 0x01, 0x81, 0x81, 0x86, 0x30, 0x81, 0xf0
    , 0x89, 0x30, 0xa9, 0xf1, 0x85, 0x30, 0xb1, 0xf5, 0x8e, 0xef
    , 0x80, 0x93, 0xe8, 0x00, 0x80, 0x91, 0xe8, 0x00, 0x80, 0xff
    , 0xfc, 0xcf, 0x82, 0x81, 0x80, 0x68, 0x80, 0x93, 0xe3, 0x00
    , 0x08, 0x95, 0x83, 0x81, 0x82, 0x30, 0x49, 0xf0, 0x82, 0x32
    , 0x31, 0xf1, 0x81, 0x30, 0x61, 0xf5, 0x29, 0xe2, 0x31, 0xe0
    , 0x42, 0xe1, 0x50, 0xe0, 0x04, 0xc0, 0x20, 0xe0, 0x31, 0xe0
    , 0x49, 0xe2, 0x50, 0xe0, 0x21, 0x15, 0x31, 0x05, 0x29, 0xf4
    , 0x81, 0xe2, 0x80, 0x93, 0xeb, 0x00, 0x30, 0xe0, 0x20, 0xe0
    , 0x86, 0x81, 0x97, 0x81, 0x8f, 0x3f, 0x91, 0x05, 0x19, 0xf0
    , 0x10, 0xf0, 0x8f, 0xef, 0x90, 0xe0, 0x48, 0x17, 0x59, 0x07
    , 0x08, 0xf4, 0xca, 0x01, 0xf9, 0x01, 0x81, 0x11, 0x0f, 0xc0
    , 0x8e, 0xef, 0x80, 0x93, 0xe8, 0x00, 0x08, 0x95, 0x84, 0x81
    , 0x40, 0x91, 0x3b, 0x01, 0x50, 0xe0, 0x2c, 0xe3, 0x31, 0xe0
    , 0x88, 0x23, 0xe9, 0xf2, 0x50, 0xe0, 0x40, 0xe0, 0xdd, 0xcf
    , 0x91, 0x91, 0x90, 0x93, 0xf1, 0x00, 0x81, 0x50, 0xea, 0xcf
    , 0x81, 0xe0, 0x80, 0x93, 0xd7, 0x00, 0x80, 0xea, 0x80, 0x93
    , 0xd8, 0x00, 0x82, 0xe1, 0x89, 0xbd, 0x09, 0xb4, 0x00, 0xfe
    , 0xfd, 0xcf, 0x80, 0xe9, 0x80, 0x93, 0xd8, 0x00, 0x81, 0xe0
    , 0x80, 0x93, 0xe0, 0x00, 0x8f, 0xe3, 0x9c, 0xe9, 0x01, 0x97
    , 0xf1, 0xf7, 0x00, 0xc0, 0x00, 0x00, 0x10, 0x92, 0xe0, 0x00
    , 0x08, 0x95, 0xaf, 0x92, 0xbf, 0x92, 0xcf, 0x92, 0xdf, 0x92
    , 0xef, 0x92, 0xff, 0x92, 0x0f, 0x93, 0x1f, 0x93, 0xcf, 0x93
    , 0xdf, 0x93, 0xcd, 0xb7, 0xde, 0xb7, 0xc0, 0x54, 0xd1, 0x09
    , 0x0f, 0xb6, 0xf8, 0x94, 0xde, 0xbf, 0x0f, 0xbe, 0xcd, 0xbf
    , 0x10, 0x92, 0xe9, 0x00, 0x80, 0x91, 0xe8, 0x00, 0x83, 0xff
    , 0x2a, 0xc0, 0x10, 0x92, 0xe9, 0x00, 0x80, 0x91, 0xf2, 0x00
    , 0x90, 0x91, 0xf3, 0x00, 0x9e, 0x01, 0x2f, 0x5f, 0x3f, 0x4f
    , 0xf9, 0x01, 0x9e, 0x2f, 0x92, 0x1b, 0x98, 0x17, 0x90, 0xf0
    , 0x8b, 0xe6, 0x80, 0x93, 0xe8, 0x00, 0x82, 0xef, 0x80, 0x93
    , 0xe8, 0x00, 0x99, 0x81, 0x89, 0x2f, 0x80, 0x76, 0x21, 0xf4
    , 0x9f, 0x71, 0x69, 0xf0, 0x91, 0x30, 0x41, 0xf0, 0x81, 0xe2
    , 0x80, 0x93, 0xeb, 0x00, 0x0a, 0xc0, 0x90, 0x91, 0xf1, 0x00
    , 0x91, 0x93, 0xe6, 0xcf, 0x8a, 0x81, 0x86, 0x30, 0xa9, 0xf7
    , 0xc9, 0x01, 0x0e, 0x94, 0x15, 0x38, 0x80, 0x91, 0xe1, 0x00
    , 0x10, 0x92, 0xe1, 0x00, 0x83, 0xff, 0x22, 0xc0, 0x10, 0x92
    , 0xe9, 0x00, 0x81, 0xe0, 0x80, 0x93, 0xeb, 0x00, 0x10, 0x92
    , 0xec, 0x00, 0x92, 0xe3, 0x90, 0x93, 0xed, 0x00, 0x28, 0xe0
    , 0x20, 0x93, 0xf0, 0x00, 0x80, 0x93, 0xe9, 0x00, 0x80, 0x93
    , 0xeb, 0x00, 0x21, 0xec, 0x20, 0x93, 0xec, 0x00, 0x90, 0x93
    , 0xed, 0x00, 0x22, 0xe0, 0x20, 0x93, 0xe9, 0x00, 0x80, 0x93
    , 0xeb, 0x00, 0x80, 0xec, 0x80, 0x93, 0xec, 0x00, 0x90, 0x93
    , 0xed, 0x00, 0x10, 0x92, 0xea, 0x00, 0x82, 0xe0, 0x80, 0x93
    , 0xe9, 0x00, 0x90, 0x91, 0xe8, 0x00, 0x95, 0xff, 0x3c, 0xc0
    , 0x80, 0x93, 0xe9, 0x00, 0x80, 0x91, 0xf2, 0x00, 0x90, 0x91
    , 0xf3, 0x00, 0x8e, 0x01, 0x0f, 0x5f, 0x1f, 0x4f, 0xf8, 0x01
    , 0x9e, 0x2f, 0x90, 0x1b, 0x98, 0x17, 0x08, 0xf4, 0x3f, 0xc0
    , 0x8b, 0xe6, 0x80, 0x93, 0xe8, 0x00, 0xea, 0x80, 0xfb, 0x80
    , 0xde, 0x80, 0x29, 0x81, 0x24, 0x30, 0x09, 0xf4, 0x70, 0xc0
    , 0x25, 0x30, 0x09, 0xf4, 0x73, 0xc0, 0x23, 0x30, 0x49, 0xf4
    , 0x7c, 0x81, 0xed, 0x81, 0x66, 0xe0, 0x86, 0xe0, 0xe8, 0x1a
    , 0xf1, 0x08, 0xf0, 0xe0, 0x6d, 0x15, 0x58, 0xf1, 0x81, 0xe0
    , 0x89, 0x83, 0x1a, 0x82, 0x94, 0xe0, 0x9b, 0x83, 0x80, 0x93
    , 0xe9, 0x00, 0xc8, 0x01, 0x80, 0x5c, 0x9f, 0x4f, 0xf8, 0x01
    , 0x21, 0x91, 0x8f, 0x01, 0x20, 0x93, 0xf1, 0x00, 0xe8, 0x17
    , 0xf9, 0x07, 0xc1, 0xf7, 0x8a, 0xe3, 0x80, 0x93, 0xe8, 0x00
    , 0xc0, 0x5c, 0xdf, 0x4f, 0x0f, 0xb6, 0xf8, 0x94, 0xde, 0xbf
    , 0x0f, 0xbe, 0xcd, 0xbf, 0xdf, 0x91, 0xcf, 0x91, 0x1f, 0x91
    , 0x0f, 0x91, 0xff, 0x90, 0xef, 0x90, 0xdf, 0x90, 0xcf, 0x90
    , 0xbf, 0x90, 0xaf, 0x90, 0x08, 0x95, 0x90, 0x91, 0xf1, 0x00
    , 0x91, 0x93, 0xb8, 0xcf, 0x86, 0x2f, 0x90, 0xe0, 0xa2, 0xe0
    , 0xb0, 0xe0, 0xac, 0x0f, 0xbd, 0x1f, 0xa8, 0x0f, 0xb9, 0x1f
    , 0x4c, 0x91, 0xd8, 0x01, 0xa8, 0x0f, 0xb9, 0x1f, 0x5c, 0x91
    , 0x45, 0x27, 0x54, 0x27, 0x45, 0x27, 0x8e, 0x0d, 0x9f, 0x1d
    , 0xaf, 0x92, 0xbf, 0x92, 0x0f, 0x92, 0x1f, 0x92, 0xff, 0x93
    , 0xef, 0x93, 0xff, 0x93, 0x0a, 0x01, 0xa7, 0x2e, 0xbe, 0x2e
    , 0xe8, 0x2f, 0xf9, 0x2f, 0x0e, 0x94, 0xf8, 0x3f, 0xff, 0x91
    , 0xef, 0x91, 0xff, 0x91, 0x1f, 0x90, 0x0f, 0x90, 0xbf, 0x90
    , 0xaf, 0x90, 0x6e, 0x5f, 0xaa, 0xcf, 0xf5, 0x01, 0x66, 0x81
    , 0xc7, 0x01, 0x8a, 0x0d, 0x9b, 0x1d, 0x0e, 0x94, 0xb8, 0x39
    , 0xc3, 0x94, 0xff, 0xef, 0xaf, 0x1a, 0xbf, 0x0a, 0xcd, 0x14
    , 0x98, 0xf3, 0x9e, 0xcf, 0x58, 0x01, 0x86, 0xe0, 0xc8, 0x2e
    , 0xe0, 0x1a, 0xf1, 0x0a, 0xf7, 0xcf, 0x81, 0xe0, 0x80, 0x93
    , 0xe0, 0x00, 0xff, 0xcf, 0xf8, 0x94, 0x80, 0xe8, 0x80, 0x93
    , 0x61, 0x00, 0x10, 0x92, 0x61, 0x00, 0x20, 0x91, 0xfc, 0x01
    , 0x30, 0x91, 0xfd, 0x01, 0x84, 0xb7, 0x80, 0x93, 0xfc, 0x01
    , 0x84, 0xb7, 0x82, 0x70, 0x14, 0xbe, 0xf0, 0xe0, 0xe0, 0xe0
    , 0x45, 0x91, 0x54, 0x91, 0x24, 0x35, 0x9a, 0xed, 0x39, 0x07
    , 0x51, 0xf0, 0x81, 0x11, 0x03, 0xc0, 0x4f, 0x3f, 0x5f, 0x4f
    , 0x19, 0xf4, 0x2b, 0x3a, 0x35, 0x42, 0x11, 0xf4, 0x0c, 0x94
    , 0x00, 0x00, 0x8b, 0xea, 0x95, 0xe2, 0x90, 0x93, 0xfd, 0x01
    , 0x80, 0x93, 0xfc, 0x01, 0xa8, 0x95, 0x88, 0xe1, 0x80, 0x93
    , 0x60, 0x00, 0x8d, 0xe0, 0x80, 0x93, 0x60, 0x00, 0x0e, 0x94
    , 0x64, 0x38, 0x0e, 0x94, 0x7e, 0x38, 0xa8, 0x95, 0xfc, 0xcf
    , 0x26, 0x2f, 0xf9, 0x99, 0xfe, 0xcf, 0x1f, 0xba, 0x92, 0xbd
    , 0x81, 0xbd, 0x20, 0xbd, 0x0f, 0xb6, 0xf8, 0x94, 0xfa, 0x9a
    , 0xf9, 0x9a, 0x0f, 0xbe, 0x01, 0x96, 0x08, 0x95, 0xf8, 0x94
    , 0xff, 0xcf, 0x09, 0x02, 0x29, 0x00, 0x01, 0x01, 0x00, 0x80
    , 0xfa, 0x09, 0x04, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00
    , 0x09, 0x21, 0x11, 0x01, 0x00, 0x01, 0x22, 0x19, 0x00, 0x07
    , 0x05, 0x81, 0x03, 0x40, 0x00, 0x01, 0x07, 0x05, 0x02, 0x03
    , 0x40, 0x00, 0x01, 0x12, 0x01, 0x10, 0x01, 0x00, 0x00, 0x00
    , 0x40, 0x66, 0x66, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00
    , 0x01, 0x19, 0x06, 0x00, 0xff, 0x09, 0x80, 0xa1, 0x80, 0x15
    , 0x00, 0x26, 0xff, 0x00, 0x75, 0x08, 0x95, 0x40, 0x09, 0x81
    , 0x81, 0x02, 0x09, 0x82, 0x91, 0x02, 0xc0, 0x00, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xa7, 0xbe, 0xe8, 0x95, 0xa7, 0xb6, 0xa0, 0xfc, 0xfd, 0xcf
    , 0xb7, 0xbe, 0xe8, 0x95, 0x08, 0x95, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    , 0xa7, 0xbe, 0xe8, 0x95, 0xa7, 0xb6, 0xa0, 0xfc, 0xfd, 0xcf
    , 0xb7, 0xbe, 0xe8, 0x95, 0x08, 0x95
};


// NOTE: Uses even numbers for ideal configurations, odd numbers for suboptimal
typedef enum {
    SPM_TYPE_STS_IDEAL = 0,
    SPM_TYPE_STS_SECONDARY = 1,
    SPM_TYPE_OUT_IDEAL = 2,
    SPM_TYPE_OUT_SECONARY = 3,
    SPM_TYPE_NONE = 7
} spm_type;

uint16_t gSpmSequenceAddr;
uint16_t boot_start;
uint16_t boot_end;

const uint8_t gBootloaderJmpVector[] = {
    0x57, 0xbf, 0xe8, 0x95, // An out, spm command.
    0x00, 0x00,             // nop
    0xFF, 0xCF,             // rjmp -1 (infinite loop)
};

extern const uint16_t bootloader_size;
extern const PROGMEM uint8_t bootloader_data[];

uint8_t find_spm(void) {
    uint8_t spmType = SPM_TYPE_NONE;
    uint16_t addr;

    for( addr=boot_start; addr < boot_end; addr+=2) {
        if ((spmType & 1) == 0) {
            break;
        }

        const uint16_t word_0 = pgm_read_word(addr+0);
        const uint16_t word_1 = pgm_read_word(addr+2);
        const uint16_t word_2 = pgm_read_word(addr+4);

        if (
            (word_0 & ~kStsRegMask) == kStsIns &&
            word_1 == kSpmCsrMem &&
            word_2 == kSpmIns
        ) {
            if (addr+8 < IDEAL_BLOCK_ADDR) {
                spmType = SPM_TYPE_STS_IDEAL;
                gSpmSequenceAddr = addr;
                break;
            } else {
                spmType = SPM_TYPE_STS_SECONDARY;
            }
        }


        // kSpmCsr (_SFR_IO_ADDR(SPMCSR))
        // kSpmCsrMem (kSpmCsr+0x20)
        // IOAddrInsMask(aPort) (((aPort&0x30)<<5)|(aPort&7))
        // kOutSpmCsrIns (0xb800 + IOAddrInsMask(kSpmCsr))
        // kOutSpmCsrRegMask 0x01f0
        // kSpmIns 0x95e8
        //
        // OUT A, Rr:
        // 16-bit Opcode
        // 1011 1AAr rrrr AAAA
        // AA.....AAAA ->
        // ..rrrrr.... ->
        //
        // A  = SPMCSR
        // Rr = register (r20 atmel DFU)

        // out SPMCSR, R20; argument 2 decides function (r18)
        // SPM                ;Store program memory
        if (
            (word_0 & ~kOutSpmCsrRegMask) == kOutSpmCsrIns &&
            word_1 == kSpmIns
        ) {
            if (addr+6 < IDEAL_BLOCK_ADDR) {
                spmType = SPM_TYPE_OUT_IDEAL;
                gSpmSequenceAddr = addr;
                break;
            } else {
                spmType = SPM_TYPE_OUT_SECONARY;
            }
        }

        // Save the SPM address
        if (spmType != SPM_TYPE_NONE) {
            gSpmSequenceAddr = addr;
        }
    }

    return spmType;
}

#define BLB1_MASK 0x30 // controls access of bootloader section
#define BLB0_MASK 0x0C // controls access of application section
#define BLB_MASK 0x03 // controls access from external progarmmer

// Check lock bits. We need to be able to do the following things:
// 1. Use the SPM instruction to write to the bootloader.
// 2. From the application section, be allowed to read the bootloader code.
// 3. When executing from the bootloader, allow interrupt code stored in the
//    application section to execute
//
// This means we need full access to the bootloader (i.e. both bits
// a BLB1 need to be unprogrammed).
uint8_t check_bootloader_lock_bits(void) {
    // uint8_t lfuse;
    // uint8_t hfuse;
    // uint8_t efuse;
    uint8_t lock_bits;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        // TODO: check other fuse bits
        // lfuse = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
        // hfuse = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
        // efuse = boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
        lock_bits = boot_lock_fuse_bits_get(GET_LOCK_BITS);
    }

    if( (lock_bits & BLB1_MASK) != BLB1_MASK) {
        return -1;
    }

    return 0;
}

void setup_timer0(uint8_t cycles) {

#if defined (__AVR_ATmega32U4__)
    TCCR0B = 0;       // stop the timer.
    TCCR0A = 0;       // mode 0, no OCR outputs.
    TCNT0 = 0;        // reset the timer
    TIFR0 = (1<<OCF0B) | (1<<OCF0A) | (1<<TOV0); // clear all pending timer0 interrupts.
    OCR0B = cycles; // number of cycles to wait
    TIMSK0 = (1<<OCIE0B); // OCR0B interrupt enabled.
#elif defined (__AVR_ATmega168__)
    // Note: Pretty sure Fignition which bootjacker was made for uses ATmega168
    TCCR0B = 0;       // stop the timer.
    TCCR0A = 0;       // mode 0, no OCR outputs.
    TCNT0 = 0;        // reset the timer
    TIFR0 = (1<<OCF0B) | (1<<OCF0A) | (1<<TOV0);  // clear all pending timer0 interrupts.
    OCR0B = cycles;   // 40 clocks from now (40 in test, 31 for real).
    TIMSK0 = (1<<OCIE0B);     // OCR0B interrupt enabled.
#else
#error "Current microcontroller is unsupported or untested."
#endif

}

// Found this value by experimentation.
// This value should be chosen so the timer0 interrupt will be called on the
// instruction immediately following the SPM instruction.
#define SPM_LEAP_CYCLES_USING_STS 40
#define SPM_LEAP_CYCLES_USING_OUT 39

// This function will call the SPM instruction we found in the bootloader
// while setting `R0:R1` <- `optValue` and `Z` <- `addr`.
//
// Note:  I'm not sure if this function will work correctly if it tries to
// modify a value in the application space.
// If the SPM instruction targets the bootloader section, then the CPU will
// be halted while she SPM operation is executed, however if the SPM instruction
// targets the application space, then code will continue executing in the
// bootloader. However the application code cannot be read while the SPM
// operation is executing, therefore it is necessary for the code to wait for
// the SPM instruction to finish executing before returning to the application
// space.
//
// We only want to update code in the bootloader, should not be an issue, but
// if we did want to do this, we would need to write our own SPM instruction
// into the bootloader space which includes a loop to wait for the SPM
// instruction to finish.
void spm_leap_cmd(uint16_t addr, uint8_t spmCmd, uint16_t optValue) {
    uint8_t cmdReg, tmp=0;

    const uint8_t spmaddr_zl = (gSpmSequenceAddr >> 0) & 0xff;
    const uint8_t spmaddr_zh = (gSpmSequenceAddr >> 8) & 0xff;
    // Will probably need this for devices that have more than 128kb flash
    // const uint8_t spmaddr_rz = (gSpmSequenceAddr >> 16) & 0xff;
    const uint8_t spmaddr_rz = 0;

    // Assume that the instruction before SPM is `OUT SPMCSR, rXX`
    // Or it is using STS SPMCSR, rXX.  Need to extract the rXX from
    // the instruction.  It's in the same place for both opcodes:
    //1001 001d dddd 0000
    cmdReg = (uint8_t)(
        (pgm_read_word(gSpmSequenceAddr)>>4) & 0x1f
    );

    PINC|=(1<<4);
    asm volatile(
        "push r0\n"
        "push r1\n"             // needed for opt command.
        "push %[tmp]\n"
        "push r30\n"
        "push r31\n"

        //wait for spm operation complete.
        "SpmLeapCmdWaitSpm: in %[tmp], %[SPM_CSR]\n" //
        "sbrc %[tmp],0\n"
        "rjmp SpmLeapCmdWaitSpm\n"

        // start the TCCR0B timer
        "ldi %[tmp],1\n"     // timer 0 start at fClk
        "out %[_TCCR0B],%[tmp]\n"    // set TCCR0B so off we go. This is time 0c.

        // To call the smp instruction, we first need to write to the SPMCSR
        // register. The variable cmdReg holds the register that will be
        // written to the SPMCSR. We save the current value of cmdReg now
        // and push it to the stack to restore later
        "movw r0, %[optValue] \n"   // set the value to be written. (1c)
        "mov r30, %[cmdReg] \n"   // get the register used by the sequence's spm command. (1c)
        "ldi r31, 0\n"    // z^reg to save. (1c)
        "ld %[tmp], Z\n"      // get the reg (2c)
        "push %[tmp]\n"      // saved it, now we can overwrite with spm command. (2c)
        "push %[cmdReg]\n" // save cmdReg

        // Push the address that will be returned to from the spm instruction.
        "ldi r30,lo8(pm(SpmLeapCmdRet))\n" // (1c)
        "ldi r31,hi8(pm(SpmLeapCmdRet))\n" // (1c)
        "push r30\n"     // (2c)
        "push r31\n"     // return address must be pushed big-endian. (2c)

        //
        "mov r30, %[spmaddr_l]\n" // lo byte of Spm sequence address (1c)
        "mov r31, %[spmaddr_h]\n" // hi byte of Spm sequence address. z^sequence in code. (1c)
        // Convert the gSpmSequenceAddr from a byte address to a word address
        "lsr r31\n"      // (1c)
        "ror r30\n"      // div 2 to get correct Spm program address. (1c)

        "push r30\n"     // (2c)
        "push r31\n"     // Spm sequence program address must be pushed big-endian. (2c)

        "push %A[addr]\n"     // before we overwrite reg used by sequence's spm command
                              // we must first save the spm target address (2c)
        "push %B[addr]\n"     // in case it would get overwritten by the st Z. (2c)

        // store the spm command into the cmdReg
        "mov r30, %[cmdReg]\n"   // get the register used by the sequence's spm command. (1c)
        "ldi r31, 0\n"    // z^reg to save. (1c)
        "st Z, %[spmCmd] \n"      // store the command in the reg. (2c)

        "pop r31\n"      // (2c)
        "pop r30\n"      // restore the spm target address into Z. // (2c)

        // the gSpmSequenceAddr is now on the top of the stack, return here
        // to enter the bootloader
        "ret\n"          // return to bootloader. (4c(16bit PC)) (5c (22bit PC))

        // sts (2c)   // alternatively OUT (1c)
        // spm (1c). 42c in total, timer should be set to 40.

        // Return from the bootloader, pop values from stack and return
        "SpmLeapCmdRet:\n"
        "pop %[cmdReg]\n"             // restore command Reg address
        "pop %[tmp]\n"                // restore command Reg value
        "mov r30, %[cmdReg]\n"
        "ldi r31,0\n"   // z^reg to save.
        "st Z,%[tmp]\n"     // pop the reg
        "pop r31\n"
        "pop r30\n"
        "pop %[tmp]\n"
        "pop r1\n"
        "pop r0\n"
            // output registers
            : "=d" (tmp),                                   // %0
              "=r" (addr)                                   // %1
            // input registers
            : [_TCCR0B] "I" (_SFR_IO_ADDR(TCCR0B)),         // %2
              [cmdReg] "r" (cmdReg),                        // %3
              [spmCmd] "r" (spmCmd),                        // %4
              [optValue] "r" (optValue),                    // %5
              [addr] "0" (addr),                            // %6
              [spmaddr_l] "r" (spmaddr_zl),                 // %7
              [spmaddr_h] "r" (spmaddr_zh),                 // %8
              [spmaddr_z] "r" (spmaddr_rz),                 // %9
              [SPM_CSR] "I" (kSpmCsr),                      // %10
              [tmp] "d" (tmp)                               // %11
    );

}

/**
 * The timer interrupt interrupted bootloader execution
 * just after the spm instruction.
 * if we ret then we'll get back to the bootloader.
 * we need to pop the return address and then ret, which
 * should take us back to the SpmLeapCommand.
 **/
// TODO: need to set this interrupt vector to the one that matches the
// timer we will add later.
ISR(TIMER0_COMPB_vect, ISR_NAKED) { // OCR0B
    asm volatile(
        "ldi r30,0\n"
        "out %[_TCCR0B],r30\n"  // stop timer 0
        "out %[_TCNT0],r30\n"  // reset timer 0.
        "ldi r30,7\n"
        "out %[_TIFR0],r30\n"  // clear interrupts on timer 0.
        "pop r31\n"     // don't care about overwiting Z because SpmLeap doesn't need it.
        "pop r30\n"
        "reti\n"
            :
            : [_TCCR0B] "I" (_SFR_IO_ADDR(TCCR0B)),
            [_TCNT0] "I" (_SFR_IO_ADDR(TCNT0)),
            [_TIFR0] "I" (_SFR_IO_ADDR(TIFR0))
    );
}


// Write the data in src to the address at
void flash_write_page(const uint8_t *src, uint16_t dst, uint8_t length) {
    // Fill the temporary buffer for the page write
    for(uint16_t addr=0; addr < length; addr+=2) {        // 64 words.
        uint16_t data = *((uint16_t*)src);
        spm_leap_cmd(dst+addr, kFlashSpmEn, data);
        src+=2; // advance to next word
    }

    // Erase and write the target page
    spm_leap_cmd(dst, kFlashSpmErase, 0);
    spm_leap_cmd(dst, kFlashSpmWritePage, 0);
}

void show_success(void) {
    cli();
    LED0_ON;
    while (1) {
    }
}

typedef uint16_t magic_t;
#define MAGIC_ADDRESS (0x200-4)
#define MAGIC_ENTER_BOOT (0xda54)
#define MAGIC_ENTER_APPL (~0xda54)
void enter_bootloader(void) {
    cli();
    wdt_reset();
    wdt_enable(WDTO_30MS);
    *(magic_t*)(MAGIC_ADDRESS) = MAGIC_ENTER_BOOT;

    while (1);
}

void bootloader_upgrade(void) {
    uint16_t our_spm_page;

    boot_start = (FLASHEND - bootloader_size)+1;
    boot_end = boot_start + bootloader_size;

    // Check if the bootloader has already been programmed
    {
        uint8_t is_match = 1;
        for (uint16_t i = 0; i < bootloader_size; ++i) {
            if (pgm_read_byte(bootloader_data+i) != pgm_read_byte(boot_start + i) ) {
                is_match = 0;
                break;
            }
        }

        if (is_match) {
            cli();
            enter_bootloader();
            while (1);
        }
    }


    // TODO: hang and print error message print error message/LEDs
    // Check the bootloader lock bits, if incompatible lock bits are found
    // then don't run the bootloader upgrade procedure
    if (check_bootloader_lock_bits()) {
        while (1) {
            LED0_TOGGLE;
            _delay_ms(500);
            LED1_TOGGLE;
            _delay_ms(500);
        }
    }

    // Find the SPM instruction and what the surrounding instructions are.
    uint8_t spmType = find_spm();

    if (spmType == SPM_TYPE_NONE) {
        // If we didn't find an SPM instruction, hang here and blink both
        // LEDs.
    }

    // Need to try and disable any interrupt source that the bootloader my have
    // setup (really the bootloader shouldn't change these from their default
    // values).
#ifdef __AVR_ATmega32U4__

    // Disable all other interrupt sources
  TIMSK0 = 0; // Disable timer 0 interrupts
  TIFR0 = 0x07;
  TIMSK1 = 0; // Disable timer 1 interrupts
  TIFR1 = 0x17;
  EIMSK = 0;  // Disable external interrupts
  EIFR = 0x03;
  PCICR = 0;  // all Pin Change interrupts off (Tape uses them).
  PCIFR = 0x01; // pending pin change interrupts cleared.

    USBCON = 0;
    USBINT = (1<<VBUSTI);

    UDIEN = 0;
    UDINT = 0xff;
#else
#error "Unsupported/tested microcontroller"
#endif

    sei(); // Need interrupts enabled

    if (spmType == SPM_TYPE_STS_SECONDARY || spmType == SPM_TYPE_STS_IDEAL) {
        setup_timer0(SPM_LEAP_CYCLES_USING_STS);   // sts timing.
    } else if (spmType == SPM_TYPE_OUT_SECONARY || spmType == SPM_TYPE_OUT_IDEAL) {
        setup_timer0(SPM_LEAP_CYCLES_USING_OUT); // out timing is one cycle less.
    }

    // if (spmType == SPM_TYPE_STS_SECONDARY || spmType == SPM_TYPE_OUT_SECONARY) {
    //     our_spm_page = BOOTLOADER_START;
    // } else {
    //     our_spm_page = BOOTLOADER_END - SPM_PAGE;
    // }
    our_spm_page = IDEAL_BLOCK_ADDR;

    flash_write_page(
        gBootloaderJmpVector,
        our_spm_page,
        sizeof(gBootloaderJmpVector)
    );

    // We write a custom block with an SPM instruction as the last page of flash.
    // It uses an out instruction, so setup the timer appropriately.
    setup_timer0(SPM_LEAP_CYCLES_USING_OUT);
    gSpmSequenceAddr = our_spm_page;

    flash_write_page(
        gBootloaderJmpVector,
        0x7000,
        sizeof(gBootloaderJmpVector)
    );

    // We can now overwrite the bootloader with our replacement bootloader.
    {
        uint16_t boot_pos = 0;

        while (
            boot_pos < bootloader_size &&
            (boot_pos < (bootloader_size-SPM_PAGESIZE))
        ) {
            uint8_t page_data[SPM_PAGESIZE];

            for (uint16_t i = 0; i < SPM_PAGESIZE; ++i) {
                page_data[i] = pgm_read_byte(bootloader_data+(boot_pos + i));
            }

            // The data is now loaded into ram, write the page
            flash_write_page(
                page_data,
                boot_start + boot_pos,
                SPM_PAGESIZE
            );
            boot_pos += SPM_PAGESIZE;

        }

        // To write the page at `BOOTLOADER_END-SPM_PAGESIZE` we can not use the
        // SPM instruction in the final page (i.e. the currently executing page).
        // So what we want to do is find another SPM instruction that we wrote
        // inside the bootloader elsewhere (obviously if there isn't any this
        // won't work).
        // TODO: check the bootloader_data meets this requirement before
        // attempting to write the bootloader.
        {
            // Find the SPM instruction and what the surrounding instructions are.
            uint8_t spmType = find_spm();

            // Set the timer for the new instruction sequence
            if (spmType == SPM_TYPE_STS_SECONDARY || spmType == SPM_TYPE_STS_IDEAL) {
                setup_timer0(SPM_LEAP_CYCLES_USING_STS);   // sts timing.
            } else {
                setup_timer0(SPM_LEAP_CYCLES_USING_OUT); // out timing is one cycle less.
            }

            // load the final page from flash
            uint8_t page_data[SPM_PAGESIZE];
            for (uint16_t i = 0; i < SPM_PAGESIZE; ++i) {
                page_data[i] = pgm_read_byte(bootloader_data+(bootloader_size-SPM_PAGESIZE + i));
            }

            flash_write_page(
                page_data,
                boot_end - SPM_PAGESIZE,
                SPM_PAGESIZE
            );
        }
    }
}

#define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))

int main(void) {
    // Clear the pre-scaler in case it was set by fuses
    CPU_PRESCALE(0); // set for 16 MHz clock

    // Disable watch dog if it is active
    wdt_disable();

    LED0_SETUP;
    LED1_SETUP;

    LED0_OFF;
    LED1_OFF;


    // We want to make sure that interrupts are executed from the application
    // section not the bootloader. In case the bootloader set IVSEL to 1, we
    // clear it here.
    {
        // NOTE: JTD, PUD are also cleared here but we don't care
        MCUCR = (1<<IVCE); // Enable change of interrupt vectors
        MCUCR = (0<<IVCE) | (0<<IVSEL); // Clear IVSEL, i.e. interrupts from app section
    }

    _delay_ms(100);

    bootloader_upgrade();

    // If we finish, wait forever
    show_success();
}

